rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %

)abbrev domain FUNEXP FunctionExport
++ FunctionExport data for a function signature,
++ i.e. it stores the information of
++    if X has Ring then
++        foo: (A, B) -> C
++          ++ some docstring
FunctionExport: with
    con: (String, String, String, SExpression) -> %
    name: % -> String
    type: % -> String
    documentation: % -> String
    condition: % -> SExpression
  == add
    Rep ==> Record(fname: String, _
                   ftype: String, _
                   fdoc: String, _
                   fcond: SExpression)
    con(n: String, t: String, d: String, c: SExpression): % ==
        per [n, t, d, c]
    name(x: %): String == rep(x).fname;
    type(x: %): String == rep(x).ftype
    documentation(x: %): String == rep(x).fdoc
    condition(x: %): SExpression == rep(x).fcond

)abbrev domain CATEXP CategoryExport
CategoryExport: with
    construct: (String, List String, SExpression) -> %
    name: % -> String
    arguments: % -> List String
    condition: % -> SExpression
  == add
    Rep ==> Record(cname: String, _
                   cargs: List String, _
                   ccond: SExpression)
    construct(n: String, a: List String, c: SExpression): % ==
        per [n, a, c]
    name(x: %): String == rep(x).cname
    arguments(x: %): List String == rep(x).cargs
    condition(x: %): SExpression == rep(x).ccond

)abbrev domain CONDATA ConstructorData
ConstructorData: with
    constructorData: Symbol -> %
    name: % -> String
    arguments: % -> List String
  == add
    Rep ==> Record(cname: String, _
                   cargs: List String, _
                   ctype: String, _
                   cdoc: String)
    constructorData(s: Symbol): % ==
        t: String := string s
        per [t, [t], t, t]
    name(x: %): String == rep(x).cname
    arguments(x: %): List String == rep(x).cargs

)abbrev package CONINF ConstructorInformation
++ Provides information about FriCAS constructors.
EXPORTS ==> Record(cats: List SExpression, sigs: List SExpression)
TYPEDOC ==> Record(ftype: String, fdoc: String)
OPSIG   ==> Record(fname: String, ftypedocs: List TYPEDOC)
DOC ==> Record(conform: String, _
               conkind: String, _
               contype: String, _
               conargs: List String, _
               conancs: List String, _
               condoc : String, _
               fopsigs: List OPSIG)

ConstructorInformation: with
    constructorForm: Symbol -> String
    constructorKind: Symbol -> String
      ++ constructorKind(c) return "category", "domain", or "package"
      ++ depending on whether c is the name of a category, domain, or package.
      ++ It returns "unknown-constructor", if the constructor is no know.
    constructorArguments: Symbol -> List String
      ++ constructorArguments(c) yields the names of the arguments of
      ++ constructor c.
    ancestors: Symbol -> List String
      ++ ancestors(c) returns the list of all categories that c inherits from.
    documentation: String -> DOC
      ++ documentation(c) returns the documentation of the constructor c.
    constructor: Symbol -> String
      ++ constructor(x) yields the constructor name for abbreviation x.
      ++ It returns the unique symbol "unknown-abbreviation" if x is not
      ++ a known abbreviation.
    constructor?: Symbol -> Boolean
      ++ constructor?(c) returns true if c is the name of a constructor,
      ++  i.e. a category, domain, or package. It returns false othervwise.
    operationAList: Symbol -> SExpression
      ++ operationAList(c) returns he exported functions of the
      ++ constructor c.
    abbreviation: Symbol -> String
      ++ abbreviation(c) yields the abbreviation of constructor c.
      ++ It returns the unique symbol "unknown-constructor" if there is no
      ++ constructor c.
    constructorCategory: Symbol -> EXPORTS
      ++ constructorCategory(c) returns a list of categories that c
      ++ inherits from.

    constructorModeMap: Symbol -> SExpression
    operation: Symbol -> SExpression
    cosig: Symbol -> SExpression
    users: Symbol -> SExpression
    dependents: Symbol -> SExpression
    modemaps: Symbol -> SExpression
    hasCategory: Symbol -> SExpression
  == add
    getDB ==> GETDATABASE$Lisp
    syUnknownAbbreviation := "unknown-abbreviation"::Symbol
    syCATEGORY := "CATEGORY"::Symbol

---- auxiliary functions
    sex2StringList(s: SExpression): List String ==
        null? s => ["NIL"]
        symbol? s => [string symbol s]
        string? s => [string s]
        integer? s => [convert integer s]
        -- It must be a list now.
        l: List SExpression := destruct s
        empty? l => ["()"]
        ls : List String :=
            concat [[concat("  ", str) for str in sex2StringList x] for x in l]
        cons("(", concat(ls, ")"))
    stringJoin(sep: String, ls: List String): String ==
        empty? ls => ""
        str: String := first ls
        for x in rest ls repeat str := concat(str, concat(sep, x))
        str
    formatName(s: SExpression): String ==
--        dbgprint("formatName", s)
        symbol? s => string symbol s
        list? s and #s = 1 and symbol? car s =>
            str: String := string symbol car s
            str = "Zero" => "0"
            str = "One"  => "1"
            error "formatName: not a special symbol"
        error "formatName: not a (special) symbol"

    sex2String(s: SExpression): String ==
        symbol? s => string symbol s
        string? s => string s
        print(s::OutputForm)
        error "sex2String: not a symbol or string"

    toString(s: SExpression, args: List String): String ==
        str: String := sex2String s
        str = "%%" => "%"
        str = "," => ", "
        str = "(" or str = ")" or str = "#" or str = " -> " => str
        if str.1 = char "#" then
            str := args(ScanArabic(str(2..#str))$NumberFormats)
        concat ["\ :ref:`", str, " <", str, ">`\ "]

    prefix2String(s: SExpression, args: List String): String ==
        x: SExpression := prefix2String(s)$Lisp
        list? x => concat [toString(sex, args) for sex in destruct x]
        toString(x, args)

    formatSignature(s: SExpression, args: List String): String ==
        z: SExpression := formatSignature(s)$Lisp
        symbol? z => string symbol z
        ls: List String := [toString(t, args) for t in destruct z]
        concat ls

    formatTypeDoc(s: SExpression, args: List String): TYPEDOC ==
        not list? s and #s ~= 2 =>
            print(s::OutputForm)
            error "formatTypeDoc: not a list"
        type: String := formatSignature(car s, args)
        doc: String := stringJoin(" ++ ", sex2StringList car cdr s)
        [type, doc]

    formatTypeDocs(s: SExpression, args: List String): List TYPEDOC ==
        not list? s =>
            print(s::OutputForm)
            error "formatTypeDocs: not a list"
        [formatTypeDoc(x, args) for x in destruct s]

    opsig(s: SExpression, args: List String): OPSIG ==
        not list? s =>
             error "opsig: not a list"
        name: String := formatName car s
        typedocs: List TYPEDOC := formatTypeDocs(cdr s, args)
        [name, typedocs]

    lt(s1: String, s2: String): Boolean == lowerCase s1 < lowerCase s2


---- end auxiliary functions

    constructorKind(c: Symbol): String ==
        sex: SExpression := getDB(c, 'CONSTRUCTORKIND)
        null? sex => "unknown-constructor"
        not symbol? sex =>
            print (sex::OutputForm)
            error "constructorKind: unknown form"
        string symbol sex

    constructorArguments(c: Symbol): List String ==
        sex: SExpression := getDB(c, 'CONSTRUCTORARGS)
        [string s for s in ((destruct sex) pretend List Symbol)]

    constructorForm(c: Symbol): String ==
        sex: SExpression := getDB(c, 'CONSTRUCTORFORM)
        not list? sex =>
            print (sex::OutputForm)
            error "constructorForm: not a list"
        l: List String := [string symbol x for x in destruct sex]
        empty? l => string c
        str: String := first l
        if str = "T$" then str := "T"
        l := rest l
        empty? l => str
        str := concat(concat(str, "("), first l)
        for s in rest l repeat
            s = "T$" => str := concat(str, ", T")
            str := concat(concat(str, ", "), s)
        concat(str, ")")

    ancestors(c: Symbol): List String ==
        sex: SExpression := getDB(c, 'ANCESTORS)
        null? sex => empty()
        args: List String := constructorArguments c
        [prefix2String(first destruct s, args) for s in destruct sex]

    documentation(str: String): DOC ==
        con: Symbol := str::Symbol
        sex: SExpression := getDB(con, 'DOCUMENTATION)
        not list? sex =>
            print (sex::OutputForm)
            error "documentation: not a list"
        cargs: List String := constructorArguments con
        ops: StringTable(List TYPEDOC) := table()
        for x in destruct sex repeat
            os: OPSIG := opsig(x, cargs)
            ops(os.fname) := os.ftypedocs
        cform: String := constructorForm con
        ckind: String := constructorKind con
        ctype: String := ""
        cancs: List String := ancestors con
        cdoc: String := ""
        if key?("constructor", ops) then
            typedocs: List TYPEDOC := ops."constructor"
            for td in typedocs repeat
                if td.ftype = "() -> ()" then (cdoc := td.fdoc; break)
            typedocs := [td for td in typedocs | td.ftype ~= "() -> ()"]
            if empty? typedocs then
                remove!("constructor", ops)
            else
                ops."constructor" := typedocs
        opsigs: List OPSIG := [[name, ops.name] for name in sort(lt, keys ops)]
        [cform, ckind, ctype, cargs, cancs, cdoc, opsigs]

    abbreviation(c: Symbol): String ==
        sex: SExpression := getDB(c, 'ABBREVIATION)
        symbol? sex => string symbol sex
        "unknown-abbreviation"
    constructor(c: Symbol): String ==
        sex: SExpression := getDB(c, 'CONSTRUCTOR)
        symbol? sex => string symbol sex
        "unknown-constructor"
    constructor?(c: Symbol): Boolean ==
        sex: SExpression := getDB(c, 'CONSTRUCTOR?)
        not null? sex
    operationAList(c: Symbol): SExpression ==
        sex: SExpression := getDB(c, 'OPERATIONALIST)

    constructorCategory(c: Symbol): EXPORTS ==
        sex: SExpression := getDB(c, 'CONSTRUCTORCATEGORY)
        null? sex => [empty(), empty()]
        not list? sex or string symbol car sex ~= "Join" =>
            print (sex::OutputForm)
            error "constructorCategory: unknown form"
        l: List SExpression := rest destruct sex
        c: List SExpression := [s for s in l | symbol car s ~= syCATEGORY]
        s: List SExpression := [s for s in l | symbol car s  = syCATEGORY]
        #s = 0 => [c, s]$EXPORTS
        #s > 1 =>
            print (sex::OutputForm)
            error "unknown signature part"
        s := rest rest destruct first s
        -- [c, [formatInfo$Lisp x for x in s]]$EXPORTS
        [c, s]$EXPORTS
    cosig(c: Symbol): SExpression ==
        sex: SExpression := getDB(c, 'COSIG)
    constructorModeMap(c: Symbol): SExpression ==
        sex: SExpression := getDB(c, 'CONSTRUCTORMODMAP)
    cosig(c: Symbol): SExpression ==
        sex: SExpression := getDB(c, 'COSIG)
    operation(c: Symbol): SExpression ==
        sex: SExpression := getDB(c, 'OPERATION)
    users(c: Symbol): SExpression ==
        sex: SExpression := getDB(c, 'USERS)
    dependents(c: Symbol): SExpression ==
        sex: SExpression := getDB(c, 'DEPENDENTS)
    modemaps(c: Symbol): SExpression ==
        sex: SExpression := getDB(c, 'MODEMAPS)
    hasCategory(c: Symbol): SExpression ==
        sex: SExpression := getDB(c, 'HASCATEGORY)
    modemaps(c: Symbol): SExpression ==
        sex: SExpression := getDB(c, 'MODEMAPS)

)abbrev package CONDOC ConstructorDocumentation
ConstructorDocumentation: with
    reStructuredText: String -> Void
    documentAll: () -> Void
  == add
    OF ==> OutputForm
    dbgprint(x: String, y: SExpression): Void ==
        print(brace([x::OF, y::OF]$List(OF)))

    endMacroIndex(line: String, params: Integer): NonNegativeInteger ==
--        print bracket bracket [line::OutputForm]$List(OutputForm)
        p: NonNegativeInteger := 0
        len: NonNegativeInteger := #line
        bc: Integer := 1 -- brace count
        while (p := p+1; p<=len) repeat
            c: Character := line.p
--            print bracket paren [p::OutputForm, c::OutputForm, line::OutputForm]$List(OutputForm)
            c = char "{" => bc := bc+1 -- next iteration
            c = char "}" =>
                bc := bc-1
                if zero? bc then
                    params := params-1
                    if zero? params then return p
        0$NonNegativeInteger

    --rhx: TODO: should rather get the raw ++ docstring.
    -- In the database a comma is seen as ",{}", thus we substitute back.
    removeCommaBraces(s: String): String ==
        -- replace ",{}" by ","
        n: Integer := 1
        while (n := position(",{}", s, n)) > 0 repeat
            s := concat(s(1..n), s(n+3..#s))
        s

    formatDoc1(doc: String, searchString: String, _
               transformArg: String->String): String ==
--        print brace [pattern::OutputForm, doc::OutputForm]$List(OutputForm)
        n: Integer := 0
        while (n := position(searchString, doc, 1)) > 0 repeat
--            print bracket [n::OutputForm, doc::OutputForm]
            prefix: String := doc(1..n-1)
            doc := doc(n+#searchString..#doc)
            n := endMacroIndex(doc, 1)
            n = 0 =>
                print(doc::OutputForm)
                error "formatDoc1: no closing brace"
            arg: String :=
                --rhx: TODO: In the database there is \spad inside \spad. Brrrr.
                formatDoc1(doc(1..n-1), searchString, (x: String): String +-> x)
            suffix: String := doc(n+1..#doc)
            doc := concat [prefix, transformArg arg, suffix]
        doc

    formatDoc2(doc: String, searchString: String, _
               transformArgs: (String,String)->String): String ==
--        print brace [searchString::OutputForm, doc::OutputForm]$List(OutputForm)
        n: Integer := 0
        n := position(searchString, doc, 1)
--        print bracket bracket [n::OutputForm, doc::OutputForm]
        while (n := position(searchString, doc, 1)) > 0 repeat
--            print bracket [n::OutputForm, doc::OutputForm]
            prefix: String := doc(1..n-1)
            doc := doc(n+#searchString..#doc)
            n := endMacroIndex(doc, 1)
            n = 0 =>
                print(doc::OutputForm)
                error "formatDoc2: no first closing brace"
            arg1: String := doc(1..n-1)
            n>=#doc or doc(n+1) ~= char "{" =>
                print(doc::OutputForm)
                error "formatSpad2: no second opening brace"
            doc := doc(n+2..#doc)
            n := endMacroIndex(doc, 1)
            n = 0 =>
                print(doc::OutputForm)
                error "formatDoc2: no second closing brace"
            arg2: String := doc(1..n-1)
            suffix: String := doc(n+1..#doc)
            doc := concat [prefix, transformArgs(arg1, arg2), suffix]
        doc

    spad(s: String): String == concat ["\ ``", s, "``\ "]
    spadtype(s: String): String == concat ["\ :ref:`", s, " <", s, ">`\ "]
    role(r: String): String -> String ==
        (s: String): String +-> concat ["\ :", r, ":`", s, "`\ "]
    emph(s: String): String == concat ["\ *", s, "*\ "]
    boldface(s: String): String == concat ["\ **", s, "**\ "]
    boldface1(s1: String, s2: String): String == concat ["\ **", s1, "**\ "]
    id(s: String): String == s
    id2(s1: String, s2: String): String == s2

    tex2rst(s: String): String ==
        s := removeCommaBraces s
        s := formatDoc1(s, "\spad{", spad)
        s := formatDoc1(s, "\spadop{",   role "spadop")
        s := formatDoc1(s, "\spadfun{",  role "spadfun")
        s := formatDoc1(s, "\spadtype{", spadtype)
        s := formatDoc1(s, "\spadatt{",  spadtype)
        s := formatDoc1(s, "{\em ", emph)
        s := formatDoc2(s, "\spadfunFrom{", boldface1)
        s := formatDoc2(s, "\indented{", id2)
        s := formatDoc1(s, "\undocumented{", (x:String):String +-> "is undocumented.")
        s := formatDoc1(s, "\spadignore{", (x:String):String +-> x)

    reStructuredText(con: String): Void ==
--        dbgprint("reST", convert c)
        f: TextFile := open(filename("", con, "rst"), "output")
        doc: DOC := documentation(con)$ConstructorInformation

        -- index the type
        writeLine!(f, concat(".. index:: ", con))
        writeLine!(f)

        -- make a label for the type
        writeLine!(f, concat [".. __", con, ":"])
        writeLine!(f)

        -- the headear
        str := copy doc.conform
        writeLine!(f, str)
        fill!(str, char "=")
        writeLine!(f, str)
        writeLine! f

        -- are we dealing with category, domain or package
        writeLine!(f, doc.conkind)
        writeLine!(f)

        -- what args does the constructor have
        for a in doc.conargs repeat
            writeLine!(f, concat("  * ", a))
        writeLine!(f)
        writeLine!(f, doc.contype)
        writeLine!(f)
        writeLine!(f, tex2rst(doc.condoc))
        writeLine!(f)
        for opsig in doc.fopsigs repeat
            n: String := opsig.fname
            tds: List TYPEDOC := opsig.ftypedocs
            for td in tds repeat
--                 dbgprint("reST e", convert e)
                writeLine!(f, ".. index::")
                writeLine!(f, concat ["   pair: ", con, "; ", n])
                writeLine!(f)
                write!(f, ":spadfun:`")
                write!(f, n)
--                write!(f, "`\ : :spadtype:`")
                write!(f, "`\ : ")
                write!(f, td.ftype)
--                write!(f, "`")
                writeLine!(f)
                writeLine!(f)
                writeLine!(f, concat("  ", tex2rst(td.fdoc)))
                writeLine!(f)
        writeLine!(f, "**Ancestors:**")
        writeLine!(f)
        for a in doc.conancs repeat
            writeLine!(f, concat("  * ", a))
        writeLine!(f)
        close! f

    -- We don't need default domains and also not the packages
    -- defined in THIS file.
    ok?(x: SExpression): Boolean ==
        s: String := string symbol x
        member?(s, ["ConstructorDocumentation", _
                    "ConstructorInformation", _
                    "FunctionExport", _
                    "CategoryExport", _
                    "ConstructorData"]$List(String)) => false
        s.(#s) ~= char "&"

    lt(s1: String, s2: String): Boolean == lowerCase s1 < lowerCase s2
    documentAll(): Void ==
        sex: SExpression := allConstructors()$Lisp
        l: List String := [string symbol x for x in destruct(sex) | ok? x]
        l := sort!(lt, l)
        f: TextFile := open(filename("", "index", "rst"), "output")
        writeLine!(f, "FriCAS Documentation")
        writeLine!(f, "====================")
        writeLine!(f)
        writeLine!(f, "Contents:")
        writeLine!(f)
        writeLine!(f, ".. toctree::")
        for c in l repeat
--        for c in l for i in 1..20 repeat
            print(c::OutputForm)
            reStructuredText c
            write!(f, "   ")
            writeLine!(f, c)
        writeLine!(f)
        writeLine!(f)
        writeLine!(f, "Tables")
        writeLine!(f, "======")
        writeLine!(f)
        writeLine!(f, "* :ref:`search`")
        writeLine!(f)
        close! f
        void()
